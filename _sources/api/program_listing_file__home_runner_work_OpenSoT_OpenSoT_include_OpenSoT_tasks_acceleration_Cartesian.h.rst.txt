
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_acceleration_Cartesian.h:

Program Listing for File Cartesian.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_acceleration_Cartesian.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/acceleration/Cartesian.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2017 IIT-ADVR
    * Authors: Arturo Laurenzi
    * email:  arturo.laurenzi@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __OPENSOT_ACCELERATION_TASK_CARTESIAN_H__
   #define __OPENSOT_ACCELERATION_TASK_CARTESIAN_H__
   
   #include <OpenSoT/Task.h>
   #include <OpenSoT/utils/Affine.h>
   #include <XBotInterface/ModelInterface.h>
   #include <XBotInterface/Utils.h>
   #include <OpenSoT/tasks/acceleration/GainType.h>
   
   
   namespace OpenSoT { namespace tasks { namespace acceleration {
       
       class Cartesian : public OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd> {
           
       public:
           
           typedef std::shared_ptr<Cartesian> Ptr;
   
           Cartesian(const std::string task_id,
                     const Eigen::VectorXd& x,
                     const XBot::ModelInterface& robot,
                     const std::string& distal_link,
                     const std::string& base_link
                    );
           
           Cartesian(const std::string task_id,
                     const XBot::ModelInterface& robot, 
                     const std::string& distal_link,
                     const std::string& base_link,
                     const AffineHelper& qddot
                    );
   
           void setGainType(GainType type);
           GainType getGainType() const;
           
           const std::string& getBaseLink() const;
           const std::string& getDistalLink() const;
           
           [[deprecated]]
           void setPositionReference(const Eigen::Vector3d& pos_ref);
   
           void setReference(const Eigen::Affine3d& ref);
           void setReference(const KDL::Frame& ref);
   
           void setReference(const Eigen::Affine3d& pose_ref,
                             const Eigen::Vector6d& vel_ref);
           void setReference(const KDL::Frame& pose_ref,
                             const KDL::Twist& vel_ref);
   
           void setReference(const Eigen::Affine3d& pose_ref,
                             const Eigen::Vector6d& vel_ref,
                             const Eigen::Vector6d& acc_ref);
           void setReference(const KDL::Frame& pose_ref,
                             const KDL::Twist& vel_ref,
                             const KDL::Twist& acc_ref);
   
           void setVirtualForce(const Eigen::Vector6d& virtual_force_ref);
   
   
           void getReference(Eigen::Affine3d& ref);
           void getReference(KDL::Frame& ref);
   
           void getReference(Eigen::Affine3d& desiredPose,
                             Eigen::Vector6d& desiredTwist);
           void getReference(KDL::Frame& desiredPose,
                             KDL::Twist& desiredTwist);
   
           void getReference(Eigen::Affine3d& desiredPose,
                             Eigen::Vector6d& desiredTwist,
                             Eigen::Vector6d& desiredAcceleration);
           void getReference(KDL::Frame& desiredPose,
                             KDL::Twist& desiredTwist,
                             KDL::Twist& desiredAcceleration);
   
           const Eigen::Vector6d& getCachedVelocityReference() const;
   
           const Eigen::Vector6d& getCachedAccelerationReference() const;
   
           const Eigen::Vector6d& getCachedVirtualForceReference() const;
   
   
           void getActualPose(Eigen::Affine3d& actual);
           void getActualPose(KDL::Frame& actual);
   
           void getActualTwist(Eigen::Vector6d& actual);
           void getActualTwist(KDL::Twist& actual);
           
           bool reset();
   
           virtual void _update(const Eigen::VectorXd& x);
           
           virtual void _log(XBot::MatLogger2::Ptr logger);
   
           void setLambda(double lambda1, double lambda2);
           virtual void setLambda(double lambda);
   
           void getLambda(double & lambda, double & lambda2);
           using Task::getLambda;
   
           const double getLambda2() const;
   
           void setOrientationGain(double orientation_gain);
           const double getOrientationErrorGain() const;
   
           const bool baseLinkIsWorld() const;
   
           bool setDistalLink(const std::string& distal_link);
   
           bool setBaseLink(const std::string& base_link);
   
           void setKp(const Eigen::Matrix6d& Kp);
   
           void setKd(const Eigen::Matrix6d& Kd);
   
           void setGains(const Eigen::Matrix6d& Kp, const Eigen::Matrix6d& Kd);
   
           const Eigen::Matrix6d& getKp() const;
   
           const Eigen::Matrix6d& getKd() const;
   
           void getGains(Eigen::Matrix6d& Kp, Eigen::Matrix6d& Kd);
   
           static bool isCartesian(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
   
           static OpenSoT::tasks::acceleration::Cartesian::Ptr asCartesian(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
           
           const Eigen::Vector6d& getError() const;
           const Eigen::Vector6d& getVelocityError() const;
   
       private:
   
           GainType _gain_type;
   
           Eigen::Vector6d _velocity_error;
   
   
           static const std::string world_name;
           
           std::string _base_link, _distal_link;
           const XBot::ModelInterface& _robot;
           AffineHelper _qddot;
           AffineHelper _cartesian_task;
           
           Eigen::MatrixXd _J;
           Eigen::Vector6d _jdotqdot;
           
           Eigen::Affine3d _pose_ref, _pose_current;
           Eigen::Vector6d _pose_error, _vel_ref, _vel_current, _acc_ref, _vel_ref_cached, _acc_ref_cached;
           
           Eigen::Vector3d _orientation_error;
   
           Eigen::Matrix6d _Kp, _Kd;
           
           double _orientation_gain;
   
           double _lambda2;
   
           Eigen::Affine3d _base_T_distal;
   
           Eigen::Affine3d _tmpMatrix, _tmpMatrix2;
   
           void compute_cartesian_inertia_inverse();
           void resetReference();
   
   
           //
           Eigen::Vector6d _virtual_force_ref, _virtual_force_ref_cached;
           Eigen::Matrix6d _Mi;
   
           Eigen::MatrixXd _tmpMatrixXd;
           Eigen::MatrixXd _Bi;
       };
       
   } } }
   
   
   
   
   
   
   #endif
