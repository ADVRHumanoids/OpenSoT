
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_Task.h:

Program Listing for File Task.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_Task.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/Task.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2014 Walkman
    * Author: Alessio Rocchi
    * email:  alessio.rocchi@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __TASK_H__
   #define __TASK_H__
   
    #include <list>
    #include <string>
    #include <vector>
    #include <OpenSoT/Constraint.h>
    #include <assert.h>
    #include <memory>
    #include <xbot2_interface/logger.h>
    #include <xbot2_interface/xbotinterface2.h>
   
    namespace OpenSoT {
   
       enum HessianType
       {
           HST_ZERO,                   
           HST_IDENTITY,               
           HST_POSDEF,                 
           HST_POSDEF_NULLSPACE,       
           HST_SEMIDEF,                
           HST_UNKNOWN                 
       };
   
       template <class Matrix_type, class Vector_type>
       class Task {
   
       public:
           typedef Task< Matrix_type, Vector_type > TaskType;
           typedef std::shared_ptr<TaskType> TaskPtr;
           typedef Constraint< Matrix_type, Vector_type > ConstraintType;
           typedef std::shared_ptr<ConstraintType> ConstraintPtr;
       protected:
   
           std::string _task_id;
   
           unsigned int _x_size;
   
           HessianType _hessianType;
   
           Matrix_type _A;
   
           Vector_type _b;
   
           Vector_type _c;
   
           Matrix_type _W;
   
           double _lambda;
   
           bool _weight_is_diagonal;
   
           std::list< ConstraintPtr > _constraints;
   
           std::vector<bool> _active_joints_mask;
   
           virtual void _update() = 0;
   
           struct istrue //predicate
           {
              bool operator()(int val) const {return val == true;}
           };
   
           virtual void applyActiveJointsMask(Matrix_type& A)
           {
               int rows = A.rows();
               for(unsigned int i = 0; i < _x_size; ++i)
               {
                   if(!_active_joints_mask[i])
                       for(unsigned int j = 0; j < rows; ++j)
                           A(j,i) = 0.0;
               }
               //TODO: is necessary here to call update()?
           }
   
           virtual void _log(XBot::MatLogger2::Ptr logger)
           {
   
           }
   
           virtual bool reset()
           {
               XBot::Logger::error("reset is not implemented for task %s \n", _task_id.c_str());
               return false;
           }
   
       private:
   
           mutable Matrix_type _WA;
   
           mutable Vector_type _Wb;
   
           mutable Matrix_type _Atranspose;
           
           bool _is_active;
           
           Matrix_type _A_last_active;
   
       public:
           Task(const std::string task_id,
                const unsigned int x_size) :
               _task_id(task_id), _x_size(x_size), _active_joints_mask(x_size), _is_active(true), _weight_is_diagonal(false)
           {
               //Eigen:
               _A.setZero(0,x_size);
               _b.setZero(0);
               _c.setZero(x_size);
               //
   
               _lambda = 1.0;
               _hessianType = HST_UNKNOWN;
               for(unsigned int i = 0; i < x_size; ++i)
                   _active_joints_mask[i] = true;
           }
   
           virtual ~Task(){}
   
           bool getWeightIsDiagonalFlag(){return _weight_is_diagonal;}
   
           void setWeightIsDiagonalFlag(const bool flag){
               _weight_is_diagonal = flag;}
   
           void setActive(const bool active_flag){
               
               if(!_is_active && active_flag && _A_last_active.rows() > 0){
                   _A = _A_last_active;
               }
               
               _is_active = active_flag;
           }
           
           
           bool isActive() const {
               return _is_active;
           }
           
           const Matrix_type& getA() const {
               return _A;
           }
   
           const HessianType getHessianAtype() { return _hessianType; }
   
           const Vector_type& getb() const { return _b; }
   
           const Matrix_type& getWA() const {
               if(_weight_is_diagonal)
                   _WA.noalias() = _W.diagonal().asDiagonal()*_A;
               else
                   _WA.noalias() = _W*_A;
               return _WA;
           }
   
           const Matrix_type& getATranspose() const {
               _Atranspose = _A.transpose(); //This brakes the use of the template!
               return _Atranspose;
           }
   
           const Vector_type& getWb() const {
               if(_weight_is_diagonal)
                   _Wb.noalias() = _W.diagonal().asDiagonal()*_b;
               else
                   _Wb.noalias() = _W*_b;
               return _Wb;
           }
   
           const Vector_type& getc() const {
               return _c;
           }
   
           const Matrix_type& getWeight() const { return _W; }
   
           virtual void setWeight(const Matrix_type& W) {
               assert(W.rows() == this->getTaskSize());
               assert(W.cols() == W.rows());
               _W = W;
           }
   
           virtual void setWeight(const double& w) {
               assert(w>=0.0);
               _W.setIdentity();
               _W = _W * w;
           }
   
           const double getLambda() const { return _lambda; }
   
           virtual void setLambda(double lambda)
           {
               if(lambda >= 0.0){
                   _lambda = lambda;
               }
           }
           
           virtual std::list< ConstraintPtr >& getConstraints() { return _constraints; }
   
           const unsigned int getXSize() const { return _x_size; }
   
           virtual const unsigned int getTaskSize() const { return _A.rows(); }
   
           void update() {
              
               
               for(typename std::list< ConstraintPtr >::iterator i = this->getConstraints().begin();
                   i != this->getConstraints().end(); ++i) (*i)->update();
               this->_update();
               
               if(!_is_active){
                   _A_last_active = _A;
                   _A.setZero(_A.rows(), _A.cols());
                   return;
               }
   
               typedef std::vector<bool>::const_iterator it_m;
               bool all_true = true;
               for( it_m active_joint = _active_joints_mask.begin();
                    active_joint != _active_joints_mask.end();
                    ++active_joint)
               {
                   if(*active_joint == false) all_true = false;
               }
   
               if(!all_true) applyActiveJointsMask(_A);
               
               
           }
   
           std::string getTaskID(){ return _task_id; }
   
           virtual std::vector<bool> getActiveJointsMask(){return _active_joints_mask;}
   
           virtual bool setActiveJointsMask(const std::vector<bool>& active_joints_mask)
           {
               if(active_joints_mask.size() == _active_joints_mask.size())
               {
                   _active_joints_mask = active_joints_mask;
   
                   applyActiveJointsMask(_A);
   
                   return true;
               }
               return false;
           }
   
           virtual void log(XBot::MatLogger2::Ptr logger)
           {
               if(_A.rows() > 0)
                   logger->add(_task_id + "_A", _A);
               if(_b.size() > 0)
                   logger->add(_task_id + "_b", _b);
               if(_W.rows() > 0)
                   logger->add(_task_id + "_W", _W);
               if(_c.size() > 0)
                   logger->add(_task_id + "_c", _c);
               logger->add(_task_id + "_lambda", _lambda);
               _log(logger);
   
               for(auto constraint : _constraints)
                   constraint->log(logger);
   
           }
   
       private: Vector_type _error_, _tmp_, _residual_;
       public:
           double computeCost(const Eigen::VectorXd& x)
           {
               _error_.noalias() = _A*x - _b;
               _tmp_.noalias() = _error_.transpose()*_W;
               _residual_.noalias() = _tmp_.transpose()*_error_;
               return _residual_[0];
           }
   
           bool checkConsistency()
           {
               bool a = true;
               //0) Check Weight size is not 0 if b.size > 0!
               if(_b.size() > 0)
               {
                   if(_W.rows() == 0){
                       XBot::Logger::error("%s: _W.rows() == %i ! \n", _W.rows());
                       a = false;}
                   if(_W.cols() == 0){
                       XBot::Logger::error("%s: _W.cols() == %i ! \n", _W.cols());
                       a = false;}
               }
   
               //1) Check Weight is square
               if(_W.rows() != _W.cols()){
                   XBot::Logger::error("%s: _W.rows() != _W.cols() -> %i != %i! \n", _task_id.c_str(), _W.rows(), _W.cols());
                   a = false;
               }
   
               //2) Check consistency between matrices
               if(_A.rows() != _b.size()){
                   XBot::Logger::error("%s: _A.rows() != _b.size() -> %i != %i! \n", _task_id.c_str(), _A.rows(), _b.size());
                   a = false;
               }
               if(_A.rows() != _W.rows()){
                   XBot::Logger::error("%s: _A.rows() != _W.rows() -> %i != %i! \n", _task_id.c_str(), _A.rows(), _W.rows());
                   a = false;
               }
   
               //3) Check task size
               if(_A.cols() != _x_size){
                   XBot::Logger::error("%s: _A.cols() != _x_size -> %i != %i! \n", _task_id.c_str(), _A.cols(), _x_size);
                   a = false;
               }
   
               //4) Check eventually c
               if(_c.size() != _x_size){
                       XBot::Logger::error("%s: _c.size() != _x_size -> %i != %i! \n", _task_id.c_str(), _c.size(), _x_size);
                       a = false;
               }
   
               //5) If the Hessian Type is ZERO we want to check that all the entries of _A and _b are zeros!
               if(_hessianType == HST_ZERO)
               {
                   if(!_A.isZero()){
                       XBot::Logger::error("%s: Hessian is HST_ZERO but _A is not all zeros! \n", _task_id.c_str());
                       a = false;
                   }
   
                   if(!_b.isZero()){
                       XBot::Logger::error("%s: Hessian is HST_ZERO but _b is not all zeros! \n", _task_id.c_str());
                       a = false;
                   }
               }
               else{
               //6) If the Hessian Type is NOT ZERO we want to check that _A and _b exists!
                   if(_A.rows() == 0 || _A.cols() == 0){
                       XBot::Logger::error("%s: _A is [%i x %i]! \n", _task_id.c_str(), _A.rows(), _A.cols());
                       a = false;
                   }
                   if(_b.size() == 0){
                       XBot::Logger::error("%s: _b size is %i!  \n", _task_id.c_str(), _b.size());
                       a = false;
                   }
               }
   
   
   
               if(_constraints.size() > 0)
               {
   
                   for(auto constraint : _constraints)
                   {
                       if(!(constraint->checkConsistency()))
                           a = false;
                   }
               }
   
               if(a)
                   XBot::Logger::info("%s is consistent!\n", _task_id.c_str());
   
               return a;
   
           }
   
       };
   
   
    }
   
   #endif
