
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_utils_collision_utils.h:

Program Listing for File collision_utils.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_utils_collision_utils.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/utils/collision_utils.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2014 Walkman
    * Author: Enrico Mingo, Alessio Rocchi, Cheng Fang, Arturo Laurenzi
    * email:  enrico.mingo@iit.it, alessio.rocchi@iit.it, arturo.laurenzi@iit.it
    *
    * This program is free software: you can redistribute it and/or modify
    * it under the terms of the GNU Lesser General Public License as published by
    * the Free Software Foundation, either version 3 of the License, or
    * (at your option) any later version.
    *
    * This program is distributed in the hope that it will be useful,
    * but WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    * GNU Lesser General Public License for more details.
    *
    * You should have received a copy of the GNU Lesser General Public License
    * along with this program. If not, see <http://www.gnu.org/licenses/>
   */
   
   #ifndef OPENSOT_COLLISION_UTILS_H_
   #define OPENSOT_COLLISION_UTILS_H_
   
   #include <kdl/frames.hpp>
   #include <limits>
   #include <list>
   #include <string>
   #include <utility>
   #include <XBotInterface/ModelInterface.h>
   #include <srdfdom_advr/model.h>
   #include <fcl/config.h>
   #include <fcl/narrowphase/distance.h>
   #include <fcl/narrowphase/collision.h>
   #include <fcl/narrowphase/collision_object.h>
   #include <moveit/collision_detection/collision_matrix.h>
   #include <moveit/robot_model/robot_model.h>
   #include <urdf/model.h>
   #include <geometric_shapes/shapes.h>
   #include <geometric_shapes/shape_operations.h>
   #include <memory>
   #include <kdl_parser/kdl_parser.hpp>
   #include <moveit_msgs/PlanningSceneWorld.h>
   
   #include <OpenSoT/utils/LinkPairDistance.h>
   
   #include <map>
   
   
   // construct vector
   inline KDL::Vector toKdl(urdf::Vector3 v)
   {
       return KDL::Vector(v.x, v.y, v.z);
   }
   
   // construct rotation
   inline KDL::Rotation toKdl(urdf::Rotation r)
   {
       return KDL::Rotation::Quaternion(r.x, r.y, r.z, r.w);
   }
   
   // construct pose
   inline KDL::Frame toKdl(urdf::Pose p)
   {
       return KDL::Frame(toKdl(p.rotation), toKdl(p.position));
   }
   
   
   class ComputeLinksDistance
   {
   
   public:
   
       ComputeLinksDistance(const XBot::ModelInterface& model,
                            urdf::ModelConstSharedPtr collision_urdf = nullptr,
                            srdf::ModelConstSharedPtr collision_srdf = nullptr);
   
       std::list<LinkPairDistance> getLinkDistances(double detectionThreshold = std::numeric_limits<double>::infinity());
   
       bool setCollisionWhiteList(std::list< LinkPairDistance::LinksPair > whiteList);
   
       bool setCollisionBlackList(std::list< LinkPairDistance::LinksPair > blackList);
   
       bool setWorldCollisions(const moveit_msgs::PlanningSceneWorld& wc);
   
       bool addWorldCollision(const std::string& id,
                              std::shared_ptr<fcl::CollisionObjectd> fcl_obj);
   
       bool removeWorldCollision(const std::string& id);
   
       void removeAllWorldCollision();
   
       bool moveWorldCollision(const std::string& id,
                               KDL::Frame new_pose);
   
       static fcl::Transform3<double> KDL2fcl(const KDL::Frame &in);
   
       static KDL::Frame fcl2KDL(const fcl::Transform3d& in);
   
       class LinksPair
       {
   
       public:
   
           std::string linkA;
           std::string linkB;
           std::shared_ptr<fcl::CollisionObjectd> collisionObjectA;
           std::shared_ptr<fcl::CollisionObjectd> collisionObjectB;
   
           LinksPair(ComputeLinksDistance* const father,
                     std::string linkA,
                     std::string linkB);
   
       };
   
       friend class ComputeLinksDistance::LinksPair;
   
       std::map<std::string, std::shared_ptr<fcl::CollisionObjectd>> getCollisionObjects(){ return _collision_obj;}
   
       bool globalToLinkCoordinates(const std::string& linkName,
                                    const fcl::Transform3<double>& w_T_f,
                                    KDL::Frame& link_T_f);
   
       bool updateCollisionObjects();
   
       std::map<std::string,KDL::Frame> getLinkToShapeTransforms();
   
       void setLinksVsEnvironment(const std::list<std::string>& links);
   
   private:
   
       collision_detection::AllowedCollisionMatrixPtr _acm;
   
       const XBot::ModelInterface& _model;
   
       robot_model::RobotModelConstPtr _moveit_model;
   
       srdf::ModelSharedPtr _srdf;
   
       urdf::ModelSharedPtr _urdf;
   
       std::map<std::string, std::shared_ptr<fcl::CollisionObjectd>> _collision_obj;
   
       std::set<std::string> _env_obj_names;
   
       std::map<std::string,KDL::Frame> _link_T_shape;
   
       bool shapeToLinkCoordinates(const std::string &linkName,
                                   const fcl::Transform3<double> &fcl_shape_T_f,
                                   KDL::Frame &link_T_f);
   
   
       bool parseCollisionObjects();
   
   
   
       void generateLinksToUpdate();
   
       std::set<std::string> _links_to_update;
   
       std::set<std::string> _links_vs_environment;
   
       void generatePairsToCheck();
   
       std::list<ComputeLinksDistance::LinksPair> _pairs_to_check;
   
       void loadDisabledCollisionsFromSRDF(const srdf::Model& srdf,
                                           collision_detection::AllowedCollisionMatrixPtr acm);
   
   
   };
   
   #endif
