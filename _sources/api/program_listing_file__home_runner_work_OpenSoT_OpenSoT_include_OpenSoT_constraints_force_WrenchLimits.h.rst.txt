
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_constraints_force_WrenchLimits.h:

Program Listing for File WrenchLimits.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_constraints_force_WrenchLimits.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/constraints/force/WrenchLimits.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2017 Cogimon
    * Author: Enrico Mingo Hoffman
    * email:  enrico.mingo@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __BOUNDS_FORCE_WRENCHLIMITS_H__
   #define __BOUNDS_FORCE_WRENCHLIMITS_H__
   
   #include <OpenSoT/constraints/GenericConstraint.h>
   #include <OpenSoT/constraints/Aggregated.h>
   #include <OpenSoT/Constraint.h>
   #include <Eigen/Dense>
   #include <memory>
   
   
    namespace OpenSoT {
       namespace constraints {
           namespace force {
               class WrenchLimits: public Constraint<Eigen::MatrixXd, Eigen::VectorXd> {
               public:
                   typedef std::shared_ptr<WrenchLimits> Ptr;
               private:
                   Eigen::VectorXd _lowerLims;
                   Eigen::VectorXd _upperLims;
   
                   Eigen::VectorXd _zeros;
   
                   OpenSoT::constraints::GenericConstraint::Ptr _constr_internal;
   
                   bool _is_released;
   
               public:
                   WrenchLimits(const std::string& contact_name,
                                const Eigen::VectorXd& lowerLims,
                                const Eigen::VectorXd& upperLims,
                                AffineHelper wrench);
   
                   void getWrenchLimits(Eigen::VectorXd& lowerLims, Eigen::VectorXd& upperLims) const;
   
                   void setWrenchLimits(const Eigen::VectorXd& lowerLims, const Eigen::VectorXd& upperLims);
   
                   void releaseContact(bool released);
   
                   bool isReleased();
   
   
               private:
                   void generateBounds();
               };
   
               class WrenchesLimits: public Constraint<Eigen::MatrixXd, Eigen::VectorXd> {
               public:
                   typedef std::shared_ptr<WrenchesLimits> Ptr;
   
                   WrenchesLimits(const std::vector<std::string>& contact_name,
                                  const Eigen::VectorXd& lowerLims,
                                  const Eigen::VectorXd& upperLims,
                                  const std::vector<AffineHelper>& wrench);
   
                   WrenchesLimits(const std::vector<std::string>& contact_name,
                                  const std::vector<Eigen::VectorXd>& lowerLims,
                                  const std::vector<Eigen::VectorXd>& upperLims,
                                  const std::vector<AffineHelper>& wrench);
   
                   WrenchesLimits(const std::map<std::string, WrenchLimits::Ptr>& wrench_lims_constraints,
                                  const std::vector<AffineHelper>& wrench);
   
                   WrenchLimits::Ptr getWrenchLimits(const std::string& contact_name);
   
                   void update();
   
               private:
                   std::map<std::string, WrenchLimits::Ptr> _wrench_lims_constraints;
                   OpenSoT::constraints::Aggregated::Ptr _aggregated_constraint;
                   virtual void generateBounds();
   
               };
           }
       }
    }
   
   #endif
