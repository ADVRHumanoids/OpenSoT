
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_solvers_BackEndFactory.h:

Program Listing for File BackEndFactory.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_solvers_BackEndFactory.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/solvers/BackEndFactory.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef _WB_SOT_SOLVERS_BE_FACTORY_H_
   #define _WB_SOT_SOLVERS_BE_FACTORY_H_
   
   #include <OpenSoT/solvers/BackEnd.h>
   #include <boost/make_shared.hpp>
   #include <type_traits>
   
   namespace OpenSoT{
       namespace solvers{
           enum class solver_back_ends{
               qpOASES,
               OSQP,
               GLPK,
               eiQuadProg,
               ODYS,
               qpSWIFT,
               proxQP
           };
   
           template < typename C, C beginVal, C endVal>
           class Iterator {
             typedef typename std::underlying_type<C>::type val_t;
             int val;
           public:
             Iterator(const C & f) : val(static_cast<val_t>(f)) {}
             Iterator() : val(static_cast<val_t>(beginVal)) {}
             Iterator operator++() {
               ++val;
               return *this;
             }
             C operator*() { return static_cast<C>(val); }
             Iterator begin() { return *this; } //default ctor is good
             Iterator end() {
                 static const Iterator endIter=++Iterator(endVal); // cache it
                 return endIter;
             }
             bool operator!=(const Iterator& i) { return val != i.val; }
           };
   
           typedef Iterator<solver_back_ends, solver_back_ends::qpOASES, solver_back_ends::proxQP> solver_back_ends_iterator;
   
           BackEnd::Ptr BackEndFactory(const solver_back_ends be_solver, const int number_of_variables,
                                  const int number_of_constraints,
                                  OpenSoT::HessianType hessian_type,
                                  const double eps_regularisation);
   
           std::string whichBackEnd(const solver_back_ends be_solver);
       }
   }
   
   #endif
