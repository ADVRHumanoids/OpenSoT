
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_acceleration_AngularMomentum.h:

Program Listing for File AngularMomentum.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_acceleration_AngularMomentum.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/acceleration/AngularMomentum.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2021 Walkman
    * Authors: Enrico Mingo Hoffman
    * email:  enrico.mingo@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __TASKS_ACCELERATION_ANGULAR_MOMENTUM_H__
   #define __TASKS_ACCELERATION_ANGULAR_MOMENTUM_H__
   
   #include <OpenSoT/Task.h>
   #include <XBotInterface/ModelInterface.h>
   #include <Eigen/Dense>
   #include <OpenSoT/utils/Affine.h>
   
   
   namespace OpenSoT {
      namespace tasks {
          namespace acceleration {
   
       #define BASE_LINK_COM "world"
       #define DISTAL_LINK_COM "CoM"
   
          class AngularMomentum : public Task < Eigen::MatrixXd, Eigen::VectorXd > {
          public:
              typedef std::shared_ptr<AngularMomentum> Ptr;
   
          private:
              XBot::ModelInterface& _robot;
   
              Eigen::Vector3d _L_d, _Ldot_d, _Ldot_ref;
              Eigen::Vector6d _L, _Momdot;
   
              Eigen::MatrixXd _Mom;
              Eigen::Matrix3d _K;
   
              void _update(const Eigen::VectorXd& x);
   
              std::string _base_link;
              std::string _distal_link;
   
              AffineHelper _qddot;
              AffineHelper _momentum_task;
   
              bool _is_init;
   
           public:
              AngularMomentum(XBot::ModelInterface& robot, const AffineHelper& qddot);
   
              ~AngularMomentum();
   
              void setReference(const Eigen::Vector3d& desiredAngularMomentum);
   
              void setReference(const Eigen::Vector3d& desiredAngularMomentum, const Eigen::Vector3d& desiredAngularMomentumVariation);
   
              void setMomentumGain(const Eigen::Matrix3d& K);
   
              const Eigen::Matrix3d& getMomentumGain() const;
   
              void getReference(Eigen::Vector3d& desiredAngularMomentum) const;
   
              void getReference(Eigen::Vector3d& desiredAngularMomentum, Eigen::Vector3d& desiredAngularMomentumVariation) const;
   
              const std::string& getBaseLink() const;
   
              const std::string& getDistalLink() const;
   
              static bool isAngularMomentum(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
   
              static OpenSoT::tasks::acceleration::AngularMomentum::Ptr asAngularMomentum(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
          };
       }
      }
   }
   
   #endif
