
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_constraints_velocity_CollisionAvoidance.h:

Program Listing for File CollisionAvoidance.h
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_constraints_velocity_CollisionAvoidance.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/constraints/velocity/CollisionAvoidance.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2014 Walkman
    * Author: Cheng Fang
    * email:  cheng.fang@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef COLLISIONAVOIDANCE_H
   #define COLLISIONAVOIDANCE_H
   
   #include <OpenSoT/Constraint.h>
   #include <OpenSoT/tasks/velocity/Cartesian.h>
   #include <xbot2_interface/xbotinterface2.h>
   #include <xbot2_interface/collision.h>
   
   #include <srdfdom/model.h>
   #include <Eigen/Dense>
   
   #include <moveit_msgs/PlanningSceneWorld.h>
   
   namespace OpenSoT { namespace constraints { namespace velocity {
   
   class CollisionAvoidance: public Constraint<Eigen::MatrixXd, Eigen::VectorXd>
   {
   
   public:
   
       typedef std::shared_ptr<CollisionAvoidance> Ptr;
       typedef std::pair<std::string, std::string> LinksPair;
       typedef XBot::Collision::CollisionModel::WitnessPointVector WitnessPointVector;
       typedef XBot::Collision::CollisionModel::LinkPairVector LinkPairVector;
   
       CollisionAvoidance(const XBot::ModelInterface& robot,
                          int max_pairs = -1,
                          urdf::ModelConstSharedPtr collision_urdf = nullptr,
                          srdf::ModelConstSharedPtr collision_srdf = nullptr);
   
       double getLinkPairThreshold();
   
       void getError(Eigen::VectorXd& e);
   
       double getDetectionThreshold();
   
       void setLinkPairThreshold(const double linkPair_threshold);
   
       void setDetectionThreshold(const double detection_threshold);
   
       void update();
   
   
       void setMaxPairs(const unsigned int max_pairs);
   
       void setCollisionList(std::set<std::pair<std::string, std::string>> collisionList);
   
   
   
       void collisionModelUpdated();
   
       bool addCollisionShape(const std::string& name,
                              const std::string& link,
                              const XBot::Collision::Shape::Variant& shape,
                              const Eigen::Affine3d& link_T_shape,
                              const std::vector<std::string>& disabled_collisions = {});
   
       // /**
       //  * @brief remove world collision with given id
       //  */
       // bool removeWorldCollision(const std::string& id);
   
        bool moveCollisionShape(const std::string& id, const Eigen::Affine3d& new_pose);
   
       void setBoundScaling(const double boundScaling);
   
       void setLinksVsEnvironment(const std::set<std::string>& links);
   
       XBot::Collision::CollisionModel& getCollisionModel();
   
       const XBot::Collision::CollisionModel& getCollisionModel() const;
   
       void getOrderedWitnessPointVector(WitnessPointVector& wp) const;
   
       void getOrderedLinkPairVector(LinkPairVector& lp) const;
   
       void getOrderedDistanceVector(std::vector<double>& d) const;
   
       const Eigen::MatrixXd& getCollisionJacobian() const;
   
       ~CollisionAvoidance();
   
   protected:
   
       bool _include_env;
   
       double _bound_scaling;
   
       double _distance_threshold;
   
       double _detection_threshold;
   
       int _max_pairs;
   
       const XBot::ModelInterface& _robot;
   
       XBot::ModelInterface::Ptr _collision_model;
   
       std::unique_ptr<XBot::Collision::CollisionModel> _dist_calc;
   
       Eigen::VectorXd _distances;
       Eigen::MatrixXd _distance_J;
       int _num_active_pairs;
       mutable WitnessPointVector _wpv;
       mutable LinkPairVector _lpv;
   
       Eigen::MatrixXd _Jtmp;
   
   };
   
   } } }
   
   
   #endif // COLLISIONAVOIDANCE_H
   
