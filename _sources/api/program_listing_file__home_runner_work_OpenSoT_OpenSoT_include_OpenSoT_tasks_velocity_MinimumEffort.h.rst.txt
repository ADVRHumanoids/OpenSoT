
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_MinimumEffort.h:

Program Listing for File MinimumEffort.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_MinimumEffort.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/velocity/MinimumEffort.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   /*
    * Copyright (C) 2014 Walkman
    * Authors:Alessio Rocchi, Enrico Mingo
    * email:  alessio.rocchi@iit.it, enrico.mingo@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __TASKS_VELOCITY_MINIMUMEFFORT_H__
   #define __TASKS_VELOCITY_MINIMUMEFFORT_H__
   
    #include <OpenSoT/Task.h>
    #include <XBotInterface/ModelInterface.h>
    #include <OpenSoT/utils/cartesian_utils.h>
   
   
    namespace OpenSoT {
       namespace tasks {
           namespace velocity {
               class MinimumEffort : public Task < Eigen::MatrixXd, Eigen::VectorXd > {
               public:
                   typedef std::shared_ptr<MinimumEffort> Ptr;
               protected:
                   Eigen::VectorXd _x;
   
                   class ComputeGTauGradient : public CostFunction {
                       public:
                       XBot::ModelInterface::Ptr _robot;
                       const XBot::ModelInterface& _model;
                       Eigen::MatrixXd _W;
                       Eigen::VectorXd _zeros, _tau;
                       Eigen::VectorXd _tau_lim;
   
                       ComputeGTauGradient(const Eigen::VectorXd& q, const XBot::ModelInterface& robot_model) :
                           _robot(XBot::ModelInterface::getModel(robot_model.getConfigOptions())),
                           _model(robot_model),
                           _W(q.rows(),q.rows()),
                           _zeros(q.rows())
                       {
                           _zeros.setZero(q.rows());
                           _W.setIdentity(q.rows(),q.rows());
   
                           _robot->syncFrom(_model);
   
                           _model.getEffortLimits(_tau_lim);
   
                           for(int i = 0; i < q.size(); ++i){
                               _W(i,i) = 1.0 / std::pow(_tau_lim(i), 2.0);
                           }
   
   //                         _robot.switchAnchor(_model.getAnchor());
   //                         _robot.setAnchor_T_World(_model.getAnchor_T_World());
                       }
   
                       double compute(const Eigen::VectorXd &q)
                       {
   //                         if(_robot.getAnchor() != _model.getAnchor())
   //                             _robot.switchAnchor(_model.getAnchor());
   
                           _robot->setJointPosition(q);
                           _robot->update();
   //                         _robot.updateiDyn3Model(cartesian_utils::fromEigentoYarp(q), true);
   
   //                         if(_model.getAnchor_T_World() != _robot.getAnchor_T_World())
   //                         {
   //                             assert("if q and anchor are the same, anchor_t_world should be the same!");
   //
   //                             _robot.setAnchor_T_World(_model.getAnchor_T_World());
   //                         }
   
                           _robot->computeGravityCompensation(_tau);
                           return _tau.transpose()* _W * _tau;
                       }
   
                       void setW(const Eigen::MatrixXd& W) { _W = W; }
   
                       const Eigen::MatrixXd& getW() {return _W;}
                   };
   
                   ComputeGTauGradient _gTauGradientWorker;
   
               public:
   
                   MinimumEffort(const Eigen::VectorXd& x, const XBot::ModelInterface& robot_model);
   
                   ~MinimumEffort();
   
                   void _update(const Eigen::VectorXd& x);
   
                   double computeEffort();
   
                   void setW(const Eigen::MatrixXd& W){
                       _gTauGradientWorker.setW(W);
                   }
   
                   const Eigen::MatrixXd& getW(){
                       return _gTauGradientWorker.getW();
                   }
   
                   void setLambda(double lambda)
                   {
                       if(lambda >= 0.0){
                           _lambda = lambda;
                           this->_update(_x);
                       }
                   }
               };
           }
       }
    }
   
   #endif
