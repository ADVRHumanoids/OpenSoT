
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_MinimumEffort.h:

Program Listing for File MinimumEffort.h
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_MinimumEffort.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/velocity/MinimumEffort.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   /*
    * Copyright (C) 2014 Walkman
    * Authors:Alessio Rocchi, Enrico Mingo
    * email:  alessio.rocchi@iit.it, enrico.mingo@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __TASKS_VELOCITY_MINIMUMEFFORT_H__
   #define __TASKS_VELOCITY_MINIMUMEFFORT_H__
   
    #include <OpenSoT/Task.h>
    #include <xbot2_interface/xbotinterface2.h>
    #include <OpenSoT/utils/cartesian_utils.h>
   
   
    namespace OpenSoT {
       namespace tasks {
           namespace velocity {
               class MinimumEffort : public Task < Eigen::MatrixXd, Eigen::VectorXd > {
               public:
                   typedef std::shared_ptr<MinimumEffort> Ptr;
               protected:
                   const XBot::ModelInterface& _model;
                   Eigen::VectorXd _q;
   
                   void _update();
   
   
                   class ComputeGTauGradient : public CostFunction {
                       public:
                       XBot::ModelInterface::Ptr _robot;
                       const XBot::ModelInterface& _model;
                       Eigen::MatrixXd _W;
                       Eigen::VectorXd _tau;
                       Eigen::VectorXd _tau_lim;
   
                       ComputeGTauGradient(const XBot::ModelInterface& robot_model) :
                           _robot(robot_model.clone()),
                           _model(robot_model),
                           _W(robot_model.getNv(), robot_model.getNv())
                       {
                           _W.setIdentity();
   
                           _robot->syncFrom(_model);
   
                           _model.getEffortLimits(_tau_lim);
   
                           for(int i = 0; i < robot_model.getNv(); ++i){
                               _W(i,i) = 1.0 / std::pow(_tau_lim(i), 2.0);
                           }
   
                       }
   
                       double compute(const Eigen::VectorXd &q)
                       {
                           _robot->setJointPosition(q);
                           _robot->update();
   
                           _robot->computeGravityCompensation(_tau);
                           return _tau.transpose()* _W * _tau;
                       }
   
                       void setW(const Eigen::MatrixXd& W) { _W = W; }
   
                       const Eigen::MatrixXd& getW() const {return _W;}
                   };
   
                   ComputeGTauGradient _gTauGradientWorker;
                   double _step;
                   Eigen::VectorXd _gradient;
                   Eigen::VectorXd _deltas;
   
               public:
   
                   MinimumEffort(const XBot::ModelInterface& robot_model, const double step = 1E-3);
   
                   ~MinimumEffort();
   
                   double computeEffort();
   
                   void setW(const Eigen::MatrixXd& W){
                       _gTauGradientWorker.setW(W);
                   }
   
                   const Eigen::MatrixXd& getW(){
                       return _gTauGradientWorker.getW();
                   }
   
                   void setLambda(double lambda)
                   {
                       if(lambda >= 0.0){
                           _lambda = lambda;
                           this->_update();
                       }
                   }
               };
           }
       }
    }
   
   #endif
