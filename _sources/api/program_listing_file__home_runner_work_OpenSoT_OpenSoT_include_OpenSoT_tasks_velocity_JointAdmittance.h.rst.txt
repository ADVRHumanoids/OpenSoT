
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_JointAdmittance.h:

Program Listing for File JointAdmittance.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_velocity_JointAdmittance.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/velocity/JointAdmittance.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef __TASKS_VELOCITY_JOINT_ADMITTANCE_H__
   #define __TASKS_VELOCITY_JOINT_ADMITTANCE_H__
   
   #include <OpenSoT/tasks/velocity/Postural.h>
   
   namespace OpenSoT {
      namespace tasks {
          namespace velocity {
          template <typename SignalType>
          class SecondOrderFilter {
   
          public:
   
              typedef std::shared_ptr<SecondOrderFilter<SignalType>> Ptr;
   
              SecondOrderFilter():
                  _omega(1.0),
                  _eps(0.8),
                  _ts(0.01),
                  _reset_has_been_called(false)
              {
                  computeCoeff();
              }
   
              SecondOrderFilter(double omega, double eps, double ts, const SignalType& initial_state):
                  _omega(omega),
                  _eps(eps),
                  _ts(ts),
                  _reset_has_been_called(false)
              {
                  computeCoeff();
                  reset(initial_state);
              }
   
              void reset(const SignalType& initial_state){
                  _reset_has_been_called = true;
                  _u = initial_state;
                  _y = initial_state;
                  _yd = initial_state;
                  _ydd = initial_state;
                  _udd = initial_state;
                  _ud = initial_state;
              }
   
              const SignalType& process(const SignalType& input){
   
                  if(!_reset_has_been_called) reset(input*0);
   
   
                  _ydd = _yd;
                  _yd = _y;
                  _udd = _ud;
                  _ud = _u;
   
   
                  _u = input;
                  _y = 1.0/_a0 * ( _u + _b1*_ud + _b2*_udd - _a1*_yd - _a2*_ydd );
   
                  return _y;
              }
   
              const SignalType& getOutput() const {
                  return _y;
              }
   
              void setOmega(double omega){
                  _omega = omega;
                  computeCoeff();
              }
   
              double getOmega()
              {
                  return _omega;
              }
   
              void setDamping(double eps){
                  _eps = eps;
                  computeCoeff();
              }
   
              double getDamping()
              {
                  return _eps;
              }
   
              void setTimeStep(double ts){
                  _ts = ts;
                  computeCoeff();
              }
   
              double getTimeStep()
              {
                  return _ts;
              }
   
          private:
   
              void computeCoeff()
              {
                  _b1 = 2.0;
                  _b2 = 1.0;
   
                  _a0 = 1.0 + 4.0*_eps/(_omega*_ts) + 4.0/std::pow(_omega*_ts, 2.0);
                  _a1 = 2 - 8.0/std::pow(_omega*_ts, 2.0);
                  _a2 = 1.0 + 4.0/std::pow(_omega*_ts, 2.0) - 4.0*_eps/(_omega*_ts);
   
              }
   
              double _omega;
              double _eps;
              double _ts;
   
              double _b1, _b2;
              double _a0, _a1, _a2;
   
              bool _reset_has_been_called;
   
              SignalType _y, _yd, _ydd, _u, _ud, _udd;
   
          };
   
          class JointAdmittance: public Postural {
           public:
              typedef std::shared_ptr<JointAdmittance> Ptr;
   
              JointAdmittance(XBot::ModelInterface &robot, XBot::ModelInterface &model);
   
              void setJointCompliance(const Eigen::MatrixXd& C);
   
              void setJointCompliance(const double C);
   
              const Eigen::MatrixXd& getJointCompliance();
   
              void getJointCompliance(Eigen::MatrixXd& C);
   
              void setFilterParams(const double time_step, const double damping, const double omega);
   
              void setFilterTimeStep(const double time_step);
   
              void setFilterDamping(const double damping);
   
              void setFilterOmega(const double omega);
   
              static bool isJointAdmittance(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
   
              static OpenSoT::tasks::velocity::JointAdmittance::Ptr asJointAdmittance(OpenSoT::Task<Eigen::MatrixXd, Eigen::VectorXd>::TaskPtr task);
   
   
           private:
              XBot::ModelInterface& _robot;
              XBot::ModelInterface& _model;
   
              void _update();
   
              SecondOrderFilter<Eigen::VectorXd> _filter;
   
              Eigen::MatrixXd _C;
   
              Eigen::VectorXd _tau, _tau_filt, _h, _q, _tau_error, _qdot_desired;
   
          };
   
          }
      }
   }
   
   #endif
