
.. _program_listing_file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_force_CoM.h:

Program Listing for File CoM.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_OpenSoT_OpenSoT_include_OpenSoT_tasks_force_CoM.h>` (``/home/runner/work/OpenSoT/OpenSoT/include/OpenSoT/tasks/force/CoM.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright (C) 2014 Walkman
    * Authors: Enrico Mingo Hoffman, Alessio Rocchi
    * email:  enrico.mingo@iit.it, alessio.rocchi@iit.it
    * Permission is granted to copy, distribute, and/or modify this program
    * under the terms of the GNU Lesser General Public License, version 2 or any
    * later version published by the Free Software Foundation.
    *
    * A copy of the license can be found at
    * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    *
    * This program is distributed in the hope that it will be useful, but
    * WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    * Public License for more details
   */
   
   #ifndef __TASKS_FORCE_COM_H__
   #define __TASKS_FORCE_COM_H__
   
   #include <OpenSoT/Task.h>
   #include <XBotInterface/ModelInterface.h>
   #include <kdl/frames.hpp>
   #include <OpenSoT/utils/Affine.h>
   
    namespace OpenSoT {
       namespace tasks {
           namespace force {
   
               class CoM : public Task < Eigen::MatrixXd, Eigen::VectorXd > {
                   
               public:
                   
                   typedef std::shared_ptr<CoM> Ptr;
                   
               private:
                   
                   #define BASE_LINK_COM "world"
                   #define DISTAL_LINK_COM "CoM"
                   
                   virtual void _log(XBot::MatLogger2::Ptr logger);
                   
                   AffineHelper _wrenches;
                   AffineHelper _com_task;
                   
                   XBot::ModelInterface& _robot;
   
                   Eigen::Vector3d _g;
   
                   Eigen::Vector3d _desiredAcceleration;
                   Eigen::Vector3d _desiredPosition;
                   Eigen::Vector3d _desiredVelocity;
   
                   Eigen::Vector3d _desiredVariationAngularMomentum;
                   Eigen::Vector3d _desiredAngularMomentum;
   
                   Eigen::Vector3d _actualPosition;
                   Eigen::Vector3d _actualVelocity;
                   Eigen::Vector3d _actualAngularMomentum;
   
                   Eigen::Vector6d _centroidalMomentum;
   
                   Eigen::MatrixXd A;
                   Eigen::MatrixXd B;
                   Eigen::MatrixXd G;
   
                   double _lambda2;
   
                   double _lambdaAngularMomentum;
   
                   void update_b();
   
                   std::vector<std::string> _links_in_contact;
   
                   Eigen::Matrix3d _I;
                   Eigen::Matrix3d _P;
                   Eigen::Affine3d _T;
                   Eigen::Matrix3d _O;
   
                   Eigen::MatrixXd __A;
                   Eigen::VectorXd __b;
   
               public:
   
                   
                   Eigen::Vector3d positionError;
                   Eigen::Vector3d velocityError;
                   Eigen::Vector3d angularMomentumError;
   
                   CoM(const Eigen::VectorXd& x, 
                       std::vector<std::string>& links_in_contact,
                       XBot::ModelInterface& robot);
                   
                   
                   CoM(std::vector<AffineHelper> wrenches,
                       std::vector<std::string>& links_in_contact,
                       XBot::ModelInterface& robot);
   
                   ~CoM();
   
                   void _update(const Eigen::VectorXd& x);
   
   
                   void setLinearReference(const Eigen::Vector3d& desiredPosition);
   
   
                   void setLinearReference(const Eigen::Vector3d& desiredPosition,
                                     const Eigen::Vector3d& desiredVelocity);
   
                   void setLinearReference(const Eigen::Vector3d& desiredPosition,
                                     const Eigen::Vector3d& desiredVelocity,
                                     const Eigen::Vector3d& desiredAcceleration);
   
                   void setAngularReference(const Eigen::Vector3d& desiredAngularMomentum);
   
                   void setAngularReference(const Eigen::Vector3d& desiredAngularMomentum,
                                            const Eigen::Vector3d& desiredVariationAngularMomentum);
   
   
                   void setLinksInContact(const std::vector<std::string>& links_in_contact);
                   std::vector<std::string> getLinksInContact();
   
   
   
                   Eigen::Vector3d getLinearReference() const;
   
                   void getLinearReference(Eigen::Vector3d& desiredPosition,
                                     Eigen::Vector3d& desiredVelocity) const;
   
                   void getLinearReference(Eigen::Vector3d& desiredPosition,
                                     Eigen::Vector3d& desiredVelocity,
                                     Eigen::Vector3d& desiredAcceleration) const;
   
                   Eigen::Vector3d getAngularReference() const;
   
                   void getAngularReference(Eigen::Vector3d& desiredAngularMomentum,
                                     Eigen::Vector3d& desiredVariationAngularMomentum) const;
   
   
                   Eigen::Vector3d getActualPosition() const;
   
                   Eigen::Vector3d getActualVelocity() const;
   
                   Eigen::Vector3d getActualAngularMomentum() const;
   
                   std::string getBaseLink();
   
                   std::string getDistalLink();
   
                   void setLambda(double lambda, double lambda2, double lambdaAngularMomentum);
   
   
                   const Eigen::Vector3d& getError();
   
                   const Eigen::Vector3d& getVelocityError();
   
                   const Eigen::Vector3d& getAngularMomentumError();
   
                   const Eigen::MatrixXd& computeA(const std::vector<std::string>& links_in_contact);
   
                   bool reset();
   
               };
           }
       }
    }
   
   #endif
