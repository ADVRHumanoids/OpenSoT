Task
====

In OpenSoT, **tasks** are utilized to construct a cost function. Considering a specific *task*, denoted as :math:`\mathcal{T}_1`, it is defined by its corresponding matrices and vectors:

.. math::
  
   \mathcal{T}_1 = \left\{ \mathbf{A}_1 \in \mathbb{R}^{m \times n}, \mathbf{W}_1 \in \mathbb{R}^{m \times m}, \mathbf{b}_1 \in \mathbb{R}^{m}, \mathbf{c}_1  \in \mathbb{R}^{n}  \right\}.
   
Multiple *Tasks* can be summed together to form complex cost fucntions, for instance :math:`\mathcal{T}_3 = \mathcal{T}_1 + \mathcal{T}_2`:

.. math::
  
   \mathcal{T}_3 = \left\{ \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}, \begin{bmatrix}\mathbf{W}_1 & \mathbf{0}\newline \mathbf{0}   & \mathbf{W}_2 \end{bmatrix}, \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix}, \mathbf{c}_1 + \mathbf{c}_2  \right\}.

The scalar cost function associated to :math:`\mathcal{T}_3` will be:

.. math::

   \begin{align}
   \mathcal{F} 
   %& = \lVert \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}\mathbf{x} -  \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix}\rVert_{\begin{bmatrix}\mathbf{W}_1 & \mathbf{0}\newline \mathbf{0}   & \mathbf{W}_2 \end{bmatrix}} + \left(\mathbf{c}_1 + \mathbf{c}_2\right)^T\mathbf{x} = \newline
   & = \left( \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}\mathbf{x} -  \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix} \right)^T \begin{bmatrix}\mathbf{W}_1 & \mathbf{0}\newline \mathbf{0}   & \mathbf{W}_2 \end{bmatrix} \left( \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}\mathbf{x} -  \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix} \right) + \left(\mathbf{c}_1 + \mathbf{c}_2\right)^T\mathbf{x} = \newline
   %& = \left(\mathbf{x}^T \begin{bmatrix} \mathbf{A}_1^T & \mathbf{A}_2^T \end{bmatrix} - \begin{bmatrix}\mathbf{b}_1^T & \mathbf{b}_2^T \end{bmatrix}\right) \begin{bmatrix}\mathbf{W}_1 & \mathbf{0}\newline \mathbf{0}   & \mathbf{W}_2 \end{bmatrix} \left( \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}\mathbf{x} -  \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix} \right) + \left(\mathbf{c}_1 + \mathbf{c}_2\right)^T\mathbf{x} = \newline
   %& = \left( \begin{bmatrix}\mathbf{x}^T\mathbf{A}_1^T\mathbf{W}_1 & \mathbf{x}^T\mathbf{A}_2^T\mathbf{W}_2 \end{bmatrix} - \begin{bmatrix} \mathbf{b}_1^T\mathbf{W}_1 & \mathbf{b}_2^T\mathbf{W}_2 \end{bmatrix}\right) \left( \begin{bmatrix}\mathbf{A}_1\newline \mathbf{A}_2 \end{bmatrix}\mathbf{x} -  \begin{bmatrix} \mathbf{b}_1\newline \mathbf{b}_2 \end{bmatrix} \right) + \left(\mathbf{c}_1 + \mathbf{c}_2\right)^T\mathbf{x} = \newline
   %& = \mathbf{x}^T\mathbf{A}_1^T\mathbf{W}_1\mathbf{A}_1\mathbf{x} + \mathbf{x}^T\mathbf{A}_2^T\mathbf{W}_2\mathbf{A}_2\mathbf{x} -2\mathbf{b}_1^T\mathbf{W}_1\mathbf{A}_1\mathbf{x} -2\mathbf{b}_2^T\mathbf{W}_2\mathbf{A}_2\mathbf{x} + \left(\mathbf{c}_1 + \mathbf{c}_2\right)^T\mathbf{x} = \newline
   & = \sum_{i = 1}^{2} \lVert \mathbf{A}_i\mathbf{x} - \mathbf{b}_i\rVert_{\mathbf{W}_i} + \sum_{i = 1}^{2}\mathbf{c}_i^T\mathbf{x},
   \end{align}

i.e. a weighted sum of cost functions associated to each *Task*.

.. note:: 
   Most of the time, the :math:`\mathbf{c}` term is used to implement the *Lasso* or an *L-1 norm*; thus, it is typically not utilized.
   
A *Task* object is inherited from the base class `Task.h <https://advrhumanoids.github.io/OpenSoT/api/classOpenSoT_1_1Task.html#exhale-class-classopensot-1-1task>`__, where the method ``_update(const Vector_type &x)`` must be implemented to assign the matrix :math:`\mathbf{A}` as ``Eigen::MatrixXd _A``, along with the vectors :math:`\mathbf{b}` as ``Eigen::VectorXd _b`` and :math:`\mathbf{c}` as ``Eigen::VectorXd _c``. **This assignment will take place every time the** ``update(const Vector_type &x)`` **method is invoked.**   
   
The ``Hessian Type`` can be set according to the type of Hessian generated by the task as:

.. math::

   \mathbf{H} = \mathbf{A}^T\mathbf{W}\mathbf{A}.

.. note::
   The information provided by the ``Hessian Type`` is used only by some back-end solvers, in particular ``qpOASES``, therefore not mandatory.

If the weight matrix :math:`\mathbf{W}` is diagonal, is possible to accelerate the computation of the Hessian, setting the ``_weight_is_diagonal`` flag to true by utilizing the ``setWeightIsDiagonalFlag(const bool flag)`` method.

You can use the ``applyActiveJointsMask(Matrix_type& A)`` function to apply a mask to the :math:`\mathbf{A}` matrix of the *Task* and set the desired columns to :math:`\mathbf{0}`.
   
If a reset procedure for a *Task* is permitted, it must be implemented using the virtual ``reset()`` method.
    
You can *activate* or *deactivate* a *Task* using the ``setActive(const bool active_flag)`` method.

.. note:: 
   When a *Task* is not active, its :math:`\mathbf{A}` matrix is set to :math:`\mathbf{0}`.

Upon invoking the ``loglog(XBot::MatLogger2::Ptr logger)`` method, the internal matrices ``_A`` and ``_W``, as well as the vectors ``_b`` and ``_c``, are stored in the file specified within the log. To record additional data, you must implement the virtual method ``_log(XBot::MatLogger2::Ptr logger)``.

SubTask
-------
A *SubTask* comprises a specific number of rows from a *Task*. The *SubTask* class facilitates the selection of adjacent and non-adjacent rows from a task by extracting sub-matrices from ``_A`` and ``_W``, along with a sub-vector from ``_b``.

.. note::
   *SubTasks* **do not make use of the** ``_c`` **vector!**

A *SubTask* can be instantiated from a *Task* using the ``SubTask(TaskPtr taskPtr, const std::list<unsigned int> rowIndices)`` constructor found in `SubTask.h <https://advrhumanoids.github.io/OpenSoT/api/classOpenSoT_1_1SubTask.html#classOpenSoT_1_1SubTask>`__.

.. note::
   A *SubTask* holds a reference to the *Task* that was used to instantiate it. As a result, any modifications applied to the primary *Task* are reflected in the *SubTask*, and vice versa. **When the** ``update(const Vector_type &x)`` **method is invoked on the** *SubTask*, **the referenced** *Task* **is also updated.**
      
A common application of a *SubTask* is to focus on a specific portion of a task. For instance, in a *Cartesian Task*, a *SubTask* can be employed to isolate the positional component while disregarding the orientation.
